#!/usr/bin/python
# This file is part of Osgende
# Copyright (C) 2014 Sarah Hoffmann
#
# This is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""
Importer of OSM planet dumps and diffs into a simplified Osmosis
style postgresql database.

Diffs must be applied in correct order in order to keep database integrity.
However, diffs can be savely reapplied, i.e. it is possible to reapply an
older diff iff all diffs that follow are reapplied as well.

Diffs must not contain duplicates. Use osmosis' simplifyChange to remove
duplicates.
"""

import sys
import os.path as ospath
import os
import codecs
import tempfile
import argparse
import psycopg2
import osmium

import osgende.common.postgisconn as postgisconn
from osgende.common.nodestore import NodeStore

class DbDumper:
    tempdir = '.'
    def __init__(self, db, table, columns):
        self.db = db
        self.table = table
        self.dumpfile = codecs.getwriter('utf-8')(
                tempfile.NamedTemporaryFile(prefix=table,dir=DbDumper.tempdir))
        self.counter = 0
        self.columns = columns
        self.linepattern = '\t'.join([u"%%(%s)s" % x for x in columns]) + '\n'
        if columns[0] == 'id':
            self.updatequery = "EXECUTE dump_%s_update(%s)" % (
                            table, ','.join(['%s' for x in columns]))
            db.prepare("dump_%s_update" % table,
                       "UPDATE %s SET (%s) = (%s) WHERE id = $1" % (
                            table, ','.join(columns[1:]),
                            ','.join(['$%d' % x for x in range(2,len(columns)+1)])))
        #print "Linepattern:",self.linepattern

    def write(self, attrs):
        self.dumpfile.write(self.linepattern % attrs)
        self.counter += 1
        if self.counter > DbDumper.maxentries:
            self.flush()
            self.counter = 0

    def flush(self):
        cur = self.db.cursor()
        self.dumpfile.flush()
        self.dumpfile.seek(0)
        cur.copy_from(self.dumpfile, self.table, null='NULL', columns=self.columns)
        self.dumpfile.seek(0)
        self.dumpfile.truncate()

    def update(self, attrs):
        #print cursor.mogrify(self.updatequery, [attrs[x] for x in self.columns] + [attrs['id']])
        cur = self.db.cursor()
        cur.execute(self.updatequery, [attrs[x] for x in self.columns])
        return (cur.rowcount == 1)



class OSMImporter(osmium.SimpleHandler):
    columns = {
        'nodes': ('id', 'tags', 'geom' ),
        'ways': ('id', 'tags', 'nodes'),
        'relations' : ('id', 'tags'),
        'relation_members' : ( 'relation_id', 'member_id', 'member_type',
                               'member_role', 'sequence_id' )
    }

    osm_types = ('node', 'way', 'relation')

    def __init__(self, options):
        super(OSMImporter, self).__init__()
        if options.createdb:
            self.makedb(options.database, options.username,
                        options.password, options.postgisdir)
        dba = self.makedba(options.database, options.username, options.password)
        self.db = postgisconn.PGDatabase(dba)
        self.cursor = self.db.cursor()
        if options.nodestore is None:
            self.nodestore = None
        else:
            self.nodestore = NodeStore(options.nodestore)

        self.reader = osmium.io.Reader(options.inputfile)
        self.is_change_file = self.reader.header().has_multiple_object_versions

        DbDumper.maxentries = options.maxentries
        DbDumper.tempdir = options.tempdir
        self.dumpers = {}
        for (tab, cols) in OSMImporter.columns.iteritems():
            self.dumpers[tab] = DbDumper(self.db, tab, cols)

        if self.is_change_file:
            for tab in OSMImporter.osm_types:
                tablename = '%s_changeset' % tab
                if tab == 'node':
                    self.dumpers[tablename] = DbDumper(self.db, tablename,
                                               ('id', 'action', 'tags', 'geom'))
                else:
                    self.dumpers[tablename] = DbDumper(self.db, tablename,
                                               ('id', 'action'))

        if options.createindices:
            self.cursor.execute("""
                ALTER TABLE ONLY nodes ADD CONSTRAINT pk_nodes PRIMARY KEY (id);
                ALTER TABLE ONLY ways ADD CONSTRAINT pk_ways PRIMARY KEY (id);
                ALTER TABLE ONLY relations ADD CONSTRAINT pk_relations PRIMARY KEY (id);
                ALTER TABLE ONLY relation_members ADD CONSTRAINT pk_relation_members
                           PRIMARY KEY (relation_id, sequence_id); """)

    def makedba(self, db, user, password):
        dba = 'dbname=%s' % db
        if user is not None:
            dba = '%s user=%s' % (dba, user)
        if password is not None:
            dba = '%s password=%s' % (dba, password)
        return dba

    def makedb(self, dbname, user, passwd, postgisdir=None):
        dba = self.makedba('postgres', user, passwd)
        tmpdb = psycopg2.connect(dba)
        tmpdb.set_isolation_level(0)
        tmpcur = tmpdb.cursor()
        tmpcur.execute('CREATE DATABASE %s' % dbname)
        print(tmpcur.statusmessage)
        tmpdb.close()

        dba = self.makedba(dbname, user, passwd)
        tmpdb = psycopg2.connect(dba)
        tmpcur = tmpdb.cursor()
        try:
            # try to create extension postgis (for postgis 2.0)
            tmpcur.execute("CREATE EXTENSION postgis;")
        except:
            # otherwise fall back to loading it from the contrib folder
            tmpdb.rollback()
            if postgisdir is None:
                # guess the directory from the postgres version
                postgisdir = ('/usr/share/postgresql/%d.%d/contrib' %
                        (tmpdb.server_version / 10000, (tmpdb.server_version / 100) % 100))
                for fl in os.listdir(postgisdir):
                    if fl.startswith('postgis'):
                        newdir = ospath.join(postgisdir, fl)
                        if ospath.isdir(newdir):
                            postgisdir = newdir
                            break
                else:
                    print('Cannot find postgis directory. Please explicitly specify with -P parameter.')
                    sys.exit(-1)
            pgscript = open(ospath.join(postgisdir, 'postgis.sql'),'r').read()
            tmpcur.execute(pgscript)
            pgscript = open(ospath.join(postgisdir, 'spatial_ref_sys.sql'), 'r').read()
            tmpcur.execute(pgscript)
        tmpcur.execute("""
                CREATE EXTENSION hstore;
                CREATE TABLE nodes(id bigint NOT NULL, tags hstore);
                SELECT AddGeometryColumn('nodes', 'geom', 4326, 'POINT', 2);
                CREATE TABLE ways (id bigint NOT NULL, tags hstore, nodes bigint[]);
                CREATE TABLE relations (id bigint NOT NULL, tags hstore);
                CREATE TABLE relation_members (
                    relation_id bigint NOT NULL,
                    member_id bigint NOT NULL,
                    member_type character(1) NOT NULL,
                    member_role text NOT NULL,
                    sequence_id int NOT NULL);
                CREATE TABLE node_changeset (id bigint NOT NULL,
                                            action character(1) NOT NULL,
                                            tags hstore);
                SELECT AddGeometryColumn('node_changeset', 'geom', 4326, 'POINT', 2);
                CREATE TABLE way_changeset (id bigint NOT NULL,
                                            action character(1) NOT NULL);
                CREATE TABLE relation_changeset (id bigint NOT NULL,
                                                 action character(1) NOT NULL);

        """)
        tmpdb.commit()
        tmpdb.close()

    def readfile(self):
        osmium.apply(self.reader, self)

        for tab in self.dumpers.itervalues():
            tab.flush()
        self.db.commit()

    def node(self, node):
        pass


    def way(self, way):
        pass

    def relation(self, rel):
        pass

if __name__ == '__main__':

    # fun with command line options
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     usage='%(prog)s [options] <osm file>')
    parser.add_argument('-d', action='store', dest='database', default='osmosis',
                       help='name of database')
    parser.add_argument('-u', action='store', dest='username', default=None,
                       help='database user')
    parser.add_argument('-p', action='store', dest='password', default=None,
                       help='password for database')
    parser.add_argument('-t', action="store", dest='tempdir', default=None,
                       help="directory to use for temporary files")
    parser.add_argument('-m', action='store', dest='maxentries', default=100000000,
                       help='Maximum number of objects to cache before writing to the database.')
    parser.add_argument('-n', action='store', dest='nodestore', default=None,
                       help='File containing the node store')
    parser.add_argument('-c', action='store_true', dest='createdb', default=False,
                       help='Create a new database and set up the tables')
    parser.add_argument('-i', action='store_true', dest='createindices', default=False,
                       help='Create primary keys and their indices')
    parser.add_argument('-P', action='store', dest='postgisdir', default=None,
                       help='Directory where postgis sql scripts are located')
    parser.add_argument('inputfile', nargs='?', default="-",
                        help='OSM input file')

    options = parser.parse_args()
    OSMImporter(options).readfile()

