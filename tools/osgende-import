#!/usr/bin/python
# This file is part of Osgende
# Copyright (C) 2014 Sarah Hoffmann
#
# This is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""
Importer of OSM planet dumps and diffs into a simplified Osmosis
style postgresql database.

Diffs must be applied in correct order in order to keep database integrity.
However, diffs can be savely reapplied, i.e. it is possible to reapply an
older diff iff all diffs that follow are reapplied as well.

Diffs must not contain duplicates. Use osmosis' simplifyChange to remove
duplicates.
"""

import sys
import os.path as ospath
import os
import threading
import codecs
import struct
import tempfile
from binascii import hexlify
import argparse
import osmium
from collections import namedtuple

import sqlalchemy as sqla
import sqlalchemy_utils as sqla_utils

from osgende.common.nodestore import NodeStore
from osgende.osmdata import OsmSourceTables


def mkdict(tags):
    return dict([(t.k, t.v) for t in tags])

def obj2action(obj):
    if obj.visible:
        return 'C' if obj.version == 1 else 'M'
    else:
        return 'D' # delete

def loc2wkb(loc):
    # PostGIS extension that includes a SRID, see postgis/doc/ZMSGeoms.txt
    return hexlify(struct.pack("=biidd", 1, 0x20000001, 4326,
                               loc.lon, loc.lat)).decode()



class CopyThread(threading.Thread):
    """Thread that starts a copy_from on the incomming file descriptor.
       The main thread pipes into the other end of this descriptor.
    """
    def __init__(self, rcv, engine, table, columns):
        threading.Thread.__init__(self)
        self.rcv = rcv
        self.engine = engine
        self.table = table
        self.columns = columns

    def run(self):
        conn = self.engine.raw_connection()
        try:
            cur = conn.cursor()
            cur.copy_from(os.fdopen(self.rcv), self.table,
                          null='NULL', columns=self.columns, size=32*1024)
            cur.close()
            conn.commit()
        finally:
            conn.close()



class DbWriter:
    """Can either copy out new input data or update existing data.
    """
    def __init__(self, engine, table):
        self.conn = engine.connect()
        self.trans = self.conn.begin()
        if hasattr(table.c, 'id'):
            self.update_func = table.update().where(table.c.id == sqla.bindparam('oid'))
            self.delete_func = table.delete().where(table.c.id == sqla.bindparam('oid'))
        else:
            self.update_func = table.insert()
            self.delete_func = table.delete().where(table.c.relation_id == sqla.bindparam('oid'))
        columns = [ str(c.name) for c in table.columns ]
        self.linepattern = '\t'.join([u"%%(%s)s" % x for x in columns]) + '\n'

        fd_rcv, fd_snd = os.pipe()
        self.out_pipe = os.fdopen(fd_snd, 'w')

        self.thread = CopyThread(fd_rcv, engine, str(table.name), columns)
        self.thread.daemon = True
        self.thread.start()

    def write(self, **attrs):
        self.out_pipe.write(self.linepattern % attrs)

    def close(self):
        self.trans.commit()
        self.conn.close()
        self.out_pipe.close()
        self.thread.join()

    def update(self, **attrs):
        result = self.conn.execute(self.update_func, attrs)
        return result.rowcount == 1

    def delete(self, oid):
        self.conn.execute(self.delete_func, {'oid' : oid })

DbWriterSet = namedtuple('DbWriterSet', 'node way relation')

class OSMImporter(osmium.SimpleHandler):
    sqltrans = { ord(u'"'): u'\\\\"',
                     ord(u'\r') : u' ', ord(u'\b'): None, ord(u'\f') : None,
                     ord(u'\n') : u' ',
                     ord(u'\t') : u' ',
                     ord(u'\\') : u'\\\\\\\\'
               }


    def __init__(self, options):
        super(OSMImporter, self).__init__()
        dburl = sqla.engine.url.URL('postgresql', username=options.username,
                                    password=options.password,
                                    database=options.database)
        if not sqla_utils.database_exists(dburl):
            if not options.createdb:
                raise RuntimeError("Database does not exist.")

            print("Creating new DB")
            sqla_utils.create_database(dburl)
        else:
            if options.createdb:
                raise RuntimeError("Database already exists.")

        self.metadata = sqla.MetaData()
        self.tables = OsmSourceTables(self.metadata)
        self.engine = sqla.create_engine(dburl, echo=options.verbose)

        if options.createdb:
            with self.engine.begin() as conn:
                conn.execute("CREATE EXTENSION postgis")
                conn.execute("CREATE EXTENSION hstore")
            self.metadata.create_all(self.engine)

        if options.nodestore is None:
            self.nodestore = None
        else:
            self.nodestore = NodeStore(options.nodestore)

        self.reader = osmium.io.Reader(options.inputfile)
        self.is_change_file = self.reader.header().has_multiple_object_versions

        self.data = DbWriterSet(
                      node=DbWriter(self.engine, self.tables.node.data),
                      way=DbWriter(self.engine, self.tables.way.data),
                      relation=DbWriter(self.engine, self.tables.relation.data))
        self.member = DbWriter(self.engine, self.tables.member.data)
        if self.is_change_file:
            self.change = DbWriterSet(
                           node=DbWriter(self.engine, self.tables.node.change),
                           way=DbWriter(self.engine, self.tables.way.change),
                           relation=DbWriter(self.engine, self.tables.relation.change))
            # use change functions
            self.node = self.node_change
            self.way = self.way_change
            self.relation = self.relation_change


    def readfile(self):
        osmium.apply(self.reader, self)

        for tab in self.data:
            tab.close()
        self.member.close()
        if self.is_change_file:
            for tab in self.change:
                tab.close()

        if self.nodestore:
            self.nodestore.close()


    def create_indices(self):
        for n in ('node', 'way', 'relation'):
            i = sqla.Index('pk_%ss' % n, self.tables[n].data.c.id, unique=True)
            i.create(self.engine)

        i = sqla.Index('pk_relation_members',
                  self.tables.member.data.c.relation_id,
                  self.tables.member.data.c.sequence_id,
                  unique=True)
        i.create(self.engine)

    def node(self, node):
        if not self.nodestore or len(node.tags) > 0:
            tagstr = self.to_tagstr(node.tags)
            self.data.node.write(id=node.id, tags=tagstr, geom=loc2wkb(node.location))
        if self.nodestore:
            self.nodestore.set_from_node(node)

    def node_change(self, node):
        tagstr = self.to_tagstr(node.tags)
        geom = loc2wkb(node.location)
        self.change.node.write(id=node.id, action=obj2action(node),
                                      tags=tagstr, geom=geom)

        if node.deleted:
            self.data.node.delete(node.id)
        else:
            if self.nodestore:
                self.nodestore.set_from_node(node)
                if len(node.tags) == 0:
                    self.data.node.delete(node.id)
                    return
            if self.data.node.update(oid=node.id, tags=mkdict(node.tags), geom=geom):
                return

            self.data.node.write(id=node.id, tags=tagstr, geom=geom)

    def way(self, way):
        nodes = u'{%s}' % (','.join([str(n.ref) for n in way.nodes]))
        self.data.way.write(id=way.id, tags=self.to_tagstr(way.tags),
                                   nodes=nodes)

    def way_change(self, way):
        self.change.way.write(id=way.id, action=obj2action(way))

        if way.deleted:
            self.data.way.delete(way.id)
        else:
            nodes = [int(x.ref) for x in way.nodes]
            if self.data.way.update(oid=way.id, tags=mkdict(way.tags), nodes=nodes):
                return

            nodes = u'{%s}' % (','.join([str(n.ref) for n in way.nodes]))
            self.data.way.write(id=way.id, tags=self.to_tagstr(way.tags),
                                       nodes=nodes)

    def relation(self, rel):
        self.data.relation.write(id=rel.id, tags=self.to_tagstr(rel.tags))
        seq = 1
        for m in rel.members:
            self.member.write(relation_id=rel.id,
                              member_id=m.ref,
                              member_type=m.type.upper(),
                              member_role=self.sqlstr(m.role),
                              sequence_id=seq)
            seq += 1

    def relation_change(self, rel):
        self.change.relation.write(id=rel.id, action=obj2action(rel))
        self.data.member.delete(rel.id)

        if rel.deleted:
            self.data.relation.delete(rel.id)
        else:
            seq = 1
            for m in rel.members:
                self.data.member.update(relation_id=rel.id,
                                               member_id=m.ref,
                                               member_type=m.type.upper(),
                                               member_role=m.role,
                                               sequence_id=seq)
                seq += 1

            if self.data.relation.update(oid=rel.id, tags=mkdict(rel.tags)):
                return

            self.data.relation.write(id=rel.id,
                                            tags=self.to_tagstr(rel.tags))

    def to_tagstr(self, tags):
        return u','.join(['"%s"=>"%s"' % (self.sqlstr(t.k), self.sqlstr(t.v))
                            for  t in tags])

    if sys.version_info[0] < 3:
        def sqlstr(self, s):
            return s.decode('utf8').translate(self.sqltrans)
    else:
        def sqlstr(self, s):
            return s.translate(self.sqltrans)



if __name__ == '__main__':

    # fun with command line options
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     usage='%(prog)s [options] <osm file>')
    parser.add_argument('-d', action='store', dest='database', default='osmosis',
                       help='name of database')
    parser.add_argument('-u', action='store', dest='username', default=None,
                       help='database user')
    parser.add_argument('-p', action='store', dest='password', default=None,
                       help='password for database')
    parser.add_argument('-n', action='store', dest='nodestore', default=None,
                       help='File containing the node store')
    parser.add_argument('-c', action='store_true', dest='createdb', default=False,
                       help='Create a new database and set up the tables')
    parser.add_argument('-i', action='store_true', dest='createindices', default=False,
                       help='Create primary keys and their indices')
    parser.add_argument('-v', action='store_true', dest='verbose', default=False,
                       help='Enable verbose output.')
    parser.add_argument('inputfile', nargs='?', default="-",
                        help='OSM input file')

    options = parser.parse_args()
    importer = OSMImporter(options)
    importer.readfile()
    if options.createindices:
        importer.create_indices()

